# -*- coding: utf-8 -*-
"""FinalIOT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-Y75FyccBtBoQ4HjzOtFmNQ8DAcQJbqx

# Data
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

sns.set_style('darkgrid')
# %matplotlib inline

data = pd.read_csv('prob1.csv')
data

data.info()

data.describe()

df = data
data.drop(['freq_x', 'a_x', 'freq_y', 'a_y', 'freq_z', 'a_z'], axis=1)

data.info()

"""## Checking details of the data"""

# To check for anymissing or duplicate values

print('Missing values in the dataset : ',data.isna().sum().sum())
print('Duplicate values in the dataset : ',data.duplicated().sum())

plt.figure(figsize = (15,5))
plt.subplot(1,2,1)
data['AnomalyDetect'].value_counts().plot(kind = 'pie', autopct = '%.2f%%')
plt.subplot(1,2,2)
sns.countplot(x = 'AnomalyDetect', data = data)
plt.show()

plt.figure(figsize = (15,15))
for i,col in enumerate(data.columns):
    plt.subplot(5,2,i+1)
    sns.boxplot(y = col, x = 'AnomalyDetect', data = data)
plt.show()

plt.figure(figsize = (15,15))
for i,col in enumerate(data.select_dtypes('number').columns):
    plt.subplot(5,2,i+1)
    sns.histplot(x = col, data = data, kde = True, hue = 'AnomalyDetect')
plt.show()

sns.pairplot(data, hue = 'AnomalyDetect')
plt.show()

plt.figure(figsize = (12,10))
sns.heatmap(data.corr(), vmin = -1.0, vmax = 1.0, center = 0, cmap = 'RdBu_r', annot = True)
plt.show()

plt.figure(figsize = (12,5))
sns.barplot(x = 'index', y = 'AnomalyDetect',data = data.corr()['AnomalyDetect'].sort_values(ascending = False).reset_index()[2:])
plt.show()

"""# Training the actual prediction model"""

y_train = data.iloc[:,5]
y_train

x_train = data.iloc[:,0:5]
x_train

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

X_train = scaler.fit_transform(x_train)

KNN = KNeighborsClassifier

from sklearn.cluster import KMeans
km = KMeans

np.all(np.isfinite(x_train))

knn = km(n_clusters=4)

# fit the model to the training set
knn.fit(x_train, y_train)

y_pred = knn.predict(x_train)

y_pred

y_pred_df = pd.Series(y_pred)

data.insert(6,'AnomalyPred', y_pred )

data

knn.predict_proba(x_train)[:,0]

from sklearn.metrics import accuracy_score

accuracy_score(y_train, y_pred_df)

from sklearn.metrics import confusion_matrix

cm = confusion_matrix(y_train, y_pred)

print('Confusion matrix\n\n', cm)
TP = cm[0,0]
print('\nTrue Positives(TP) = ', TP)
TN = cm[1,1]
print('\nTrue Negatives(TN) = ', TN)
FP = cm[0,1]
print('\nFalse Positives(FP) = ', FP)
FN = cm[1,0]
print('\nFalse Negatives(FN) = ', FN)



plt.figure(figsize=(6,4))

cm_matrix = pd.DataFrame(data=cm, columns=['Actual Positive:1', 'Actual Negative:0'], 
                                 index=['Predict Positive:1', 'Predict Negative:0'])

sns.heatmap(cm_matrix, annot=True, fmt='d', cmap='YlGnBu')

classification_error = (FP + FN) / float(TP + TN + FP + FN)
print('Classification error : {0:0.4f}'.format(classification_error))

precision = TP / float(TP + FP)
print('Precision : {0:0.4f}'.format(precision))

recall = TP / float(TP + FN)
print('Recall or Sensitivity : {0:0.4f}'.format(recall))

"""# Making a linear Regression model for predictin of maintainence"""

import pandas
from sklearn import linear_model

X = data.iloc[:,0:5]
y = data.iloc[:,7]

regr = linear_model.LinearRegression()
regr.fit(X, y)

y_pred_linreg = regr.predict(X)
y_pred_linreg

plt.scatter(y, y_pred_linreg);
plt.xlabel('Actual');
plt.ylabel('Predicted');

sns.regplot(x=y, y=y_pred_linreg, ci=None, color ='red');

"""# Taking the value using MQTT"""

!sudo pip install paho-mqtt
!sudo apt-get install python-dev

import os
import time
import sys
import paho.mqtt.client as mqtt
import json
import random

def on_connect(client, userdata, flags, rc):
    print('CONNACK received with code %d.' % (rc))

import paho

client = mqtt.Client()
client.on_connect = on_connect
client.connect('broker.hivemq.com', 1883)

mqtt.Client(client_id='1', clean_session=True, userdata=None, protocol=mqtt.MQTTv31)

msg = None

def on_publish(client, userdata, mid):
    print("mid: "+str(mid))

def run():
    client = connect_mqtt()
    subscribe(client)
    client.loop_forever()

client = mqtt.Client()
client.on_publish = on_publish
client.connect('broker.mqttdashboard.com', 1883)
client.loop_start()

def on_message(client, userdata, message):
    print("received message: " ,str(message.payload.decode("utf-8")))

def subscribe(client):
    def on_message(client, userdata, msg):
        print(f"Received `{msg.payload.decode()}` from `{msg.topic}` topic")

def connect_mqtt() -> client:
    def on_connect(client, userdata, flags, rc):
        if rc == 0:
            print("Connected to MQTT Broker!")
        else:
            print("Failed to connect, return code %d\n", rc)

topic = "ConveyorBelt1"

client.subscribe(topic)
client.on_message = on_message

while True:
    characters = [chr(ascii) for ascii in msg.payload] # Convert ASCII to char
    chars_joined = ''.join(characters) # Join chars to a string
    splitted = chars_joined.split(",")
    acc = splitted[0]
    temp = splitted[1]
    freq_x = splitted[2]
    a_x = splitted[3]
    freq_y = splitted[4]
    a_y = splitted[5]
    freq_z = splitted[6]
    a_z = splitted[7]

    time.sleep(30)

vib_x = freq_x/a_x
vib_y = freq_y/a_y
vib_z = freq_z/a_z

"""# Testing data"""

import random

acc1 = 40+(random.random()*35)
temp1 = 150+(random.random()*25)
freq_x1 = 80+(random.random()*25)
a_x1 = random.random()*0.002
freq_y1 = 60+(random.random()*10)
a_y1 = random.random()*0.001
freq_z1 = 50+(random.random()*10)
a_z1 = random.random()*0.006

vib_x1 = freq_x/a_x
vib_y1 = freq_y/a_y
vib_z1 = freq_z/a_z

acc2 = 40+(random.random()*35)
temp2 = 150+(random.random()*25)
freq_x2 = 80+(random.random()*25)
a_x2 = random.random()*0.002
freq_y2 = 60+(random.random()*10)
a_y2 = random.random()*0.001
freq_z2 = 50+(random.random()*10)
a_z2 = random.random()*0.006

vib_x2 = freq_x/a_x
vib_y2 = freq_y/a_y
vib_z2 = freq_z/a_z

x_test = [[acc1, temp1, vib_x1, vib_y1, vib_z1], [acc2, temp2, vib_x2, vib_y2, vib_z2]]
x_test

y_pred_test = knn.predict(x_test)

y_pred_test

"""# Sending an alert"""

pip install telebot

pip install telebot

pip install telethon

import telebot
from telethon.sync import TelegramClient
from telethon.tl.types import InputPeerUser, InputPeerChannel
from telethon import TelegramClient, sync, events

api_id = '24804615'
api_hash = 'd5c6f0ad6aaa15006851468f6a064eda'
token = '5627588564:AAGrYQQJMky9q3XbMRg68JZ08ZIvuFboQT4'
message = "Working..."

phone = '+919004979252'

client = TelegramClient('session', api_id, api_hash)
  
client.connect()

import urllib.request

webUrl = urllib.request.urlopen('https://api.telegram.org/bot5627588564:AAGrYQQJMky9q3XbMRg68JZ08ZIvuFboQT4/sendMessage?chat_id=1839649176&text=MaintainenceRequired')
